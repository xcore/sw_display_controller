% Generated by Sphinx.
\def\sphinxdocclass[english]{xmosmodern}
\documentclass[  collection]{xmosmodern}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}

\usepackage{longtable}



\title{Display controller component}
\date{November 15, 2013}
\author{}
\newcommand{\sphinxlogo}{}
\newcommand{\releasename}{Release}
\usepackage{xsphinx}
\usepackage{threeparttable}
\usepackage{fancyvrb}
\usepackage{indent}
\renewcommand\bfcode\textbf
\renewcommand\bf\textbf
\graphicspath{{./}{./images/}}
\makeindex

\newcommand\PYGZat{@}
\newcommand\PYGZlb{[}
\newcommand\PYGZrb{]}

\setlength{\emergencystretch}{8em}
\start

\maketitle
\pretoc
\phantomsection\label{index::doc}

%summary!

% NON-FULLWIDTH SECTION



% NON-FULLWIDTH SECTION
\clearpage
\chapter{Overview}
\label{overview:display-controller-component}\label{overview::doc}\label{overview:overview}%summary!
\begin{inthisdocument}
\item \nameref{overview:features}
\item \nameref{overview:memory-requirements}
\item \nameref{overview:resource-requirements}
\item \nameref{overview:performance}
\end{inthisdocument}



The display controller module is used to drive a single graphics LCD screen up to 800 * 600 pixels incorporating a managed double buffer.



% NON-FULLWIDTH SECTION
\section{Features}
\label{overview:features}\begin{itemize}
\item   Non-blocking SDRAM management.

\item   Real time servicing of the LCD.

\item   Touch interactive display

\item   Image memory manager to simplify handling of images.

\item   No real time constraints on the application.

\end{itemize}




% NON-FULLWIDTH SECTION
\section{Memory requirements}
\label{overview:memory-requirements}
\begin{tabular}{ll}
\Toprule
\textbf{Resource} & \textbf{Usage}\\
\midrule
Stack & 6198 bytes\\
Program & 11306 bytes\\
\bottomrule
\end{tabular}




% NON-FULLWIDTH SECTION
\section{Resource requirements}
\label{overview:resource-requirements}
\begin{tabular}{ll}
\Toprule
\textbf{Resource} & \textbf{Usage}\\
\midrule
Channels & 3\\
Timers & 0\\
Clocks & 0\\
Threads & 1\\
\bottomrule
\end{tabular}




% NON-FULLWIDTH SECTION
\section{Performance}
\label{overview:performance}

The achievable effective bandwidth varies according to the available xCORE MIPS. The maximum pixel clock supported is 25MHz.



% NON-FULLWIDTH SECTION
\clearpage
\chapter{Hardware requirements}
\label{hw::doc}\label{hw:evaluation-platforms}%summary!
\begin{inthisdocument}
\item \nameref{hw:sec-hardware-platforms}
\item \nameref{hw:demonstration-applications}
\end{inthisdocument}




% NON-FULLWIDTH SECTION
\section{Recommended hardware}
\label{hw:sec-hardware-platforms}\label{hw:recommended-hardware}


% NON-FULLWIDTH SECTION
\subsection{sliceKIT}
\label{hw:slicekit}

This module may be evaluated using the sliceKIT modular development platform, available from digikey. Required board SKUs are:
\begin{itemize}
\item   XP-SKC-L2 (SliceKIT L2 Core Board)

\item   XA-SK-SCR480 plus XA-SK-XTAG2 (sliceKIT xTAG adaptor)

\end{itemize}




% NON-FULLWIDTH SECTION
\section{Demonstration applications}
\label{hw:demonstration-applications}


% NON-FULLWIDTH SECTION
\subsection{Display controller application}
\label{hw:display-controller-application}\begin{itemize}
\item   Package: sw\_display\_controller

\item   Application: app\_display\_controller

\end{itemize}



This combination demo employs the \verb`module_lcd` along with the \verb`module_sdram`, \verb`module_touch_controller_lib`, \verb`module_i2c_master` and the \verb`module_display_controller` framebuffer framework component to implement a 480x272 display controller.


Required board SKUs for this demo are:
\begin{itemize}
\item   XP-SKC-L16 (sliceKIT L16 Core Board) plus XA-SK-XTAG2 (sliceKIT xTAG adaptor)

\item   XA-SK-SDRAM

\item   XA-SK-SCR480 (which includes a 480x272 color touch screen)

\end{itemize}




% FULLWIDTH SECTION (with summary)
\clearpage
\chapter{API}
\label{api:sec-display-controller-api}\label{api::doc}\label{api:project-structure}%summary!
\begin{inthisdocument}
\item \nameref{api:configuration-defines}
\item \nameref{api:api}
\end{inthisdocument}

\begin{fullwidth} % chapter!
\begin{description}
\item[To build a project including the \ttfamily module\_display\_controller the following components are required:]\begin{itemize}
\item   component: sc\_sdram\_burst which handles the SDRAM

\item   component: sc\_lcd which handles the LCD

\end{itemize}


\end{description}



The below section details the APIs in the application. For details about the LCD and SDRAM APIs please refer to the respective repositories.


\section{Configuration defines}
\label{api:configuration-defines}

The \verb`module_display_controller` can be configured via the header \verb`display_controller_conf.h`. The module requires nothing to be additionally defined however any of the defines can be overridden by adding the header \verb`display_controller_conf.h` to the application project and adding the define that needs overridding. The possible defines are:
\begin{description}
\item[\textbf{DISPLAY\_CONTROLLER\_MAX\_IMAGES}]

This defines the storage space allocated to the display controller for it to store image metadata. When an image is registered with the display controller its dimensions and location in SDRAM address space are stored in a table. The define specifies how many entries are allowed in that table. Note, there is no overflow checking by default.

\item[\textbf{DISPLAY\_CONTROLLER\_VERBOSE}]

This define switches on the error checking for memory overflows and causes verbose error warnings to be emitted in the event of an error.

\end{description}



\section{API}
\label{api:api}\begin{description}
\item[The{}`{}`module\_display\_controller{}`{}` functionality is defined in]\begin{itemize}
\item   \verb`display_controller_client.xc`

\item   \verb`display_controller_internal.h`

\item   \verb`display_controller.xc`

\item   \verb`display_controller.h`

\item   \verb`transitions.h`

\item   \verb`transitions.xc`

\end{itemize}


\end{description}



The display controller handles the double buffering of the image data to the LCD as a real time service and manages the I/O to the SDRAM as a non-real time service.


The display controller API is as follows:
\index{display\_controller (C function)}

\texttt{\phantomsection\label{api:display_controller}void display\_controller(chanend c\_client, chanend c\_lcd, chanend c\_sdram)}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Function to manage the LCd c\_server and SDRAM server whilst maintaining image buffers.


This function has the following parameters:

\begin{option}

\item[c\_client]The channel from the display\_controller to the client application.
\item[c\_lcd]The channel from the display\_controller to the LCd c\_server.
\item[c\_sdram]The channel from the display\_controller to the SDRAM server.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_image\_read\_line (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_image_read_line}void display\_controller\_image\_read\_line(\= chanend c\_server,\\ 
\> unsigned line,\\ 
\> unsigned image\_no,\\ 
\> unsigned buffer{[}{]})
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

The function reads a line of pixel data from the SDRAM.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[line]The image line number to be read.
\item[image\_no]The image number whose line is to be read.
\item[buffer{[}{]}]The buffer which is to be filled with the read data.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_image\_read\_line\_p (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_image_read_line_p}void display\_controller\_image\_read\_line\_p(\= chanend c\_server,\\ 
\> unsigned line,\\ 
\> unsigned image\_no,\\ 
\> intptr\_t buffer)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

The function reads a line of pixel data from the SDRAM.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[line]The image line number to be read.
\item[image\_no]The image number whose line is to be read.
\item[buffer]A pointer to the buffer which is to be filled with the read data.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_image\_write\_line (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_image_write_line}void display\_controller\_image\_write\_line(\= chanend c\_server,\\ 
\> unsigned line,\\ 
\> unsigned image\_no,\\ 
\> unsigned buffer{[}{]})
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

The function writes a line of pixel data to the registered image in SDRAM.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[line]The image line number to be written.
\item[image\_no]The image number whose line is to be written.
\item[buffer{[}{]}]The buffer which is to be written to the image.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_image\_write\_line\_p (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_image_write_line_p}void display\_controller\_image\_write\_line\_p(\= chanend c\_server,\\ 
\> unsigned line,\\ 
\> unsigned image\_no,\\ 
\> intptr\_t buffer)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

The function writes a line of pixel data to the registered image in SDRAM.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[line]The image line number to be written.
\item[image\_no]The image number whose line is to be written.
\item[buffer]A pointer to the buffer which is to be written to the image.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_image\_read\_partial\_line (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_image_read_partial_line}void display\_controller\_image\_read\_partial\_line(\= chanend c\_server,\\ 
\> unsigned line,\\ 
\> unsigned image\_no,\\ 
\> unsigned buffer{[}{]},\\ 
\> unsigned line\_offset,\\ 
\> unsigned word\_count,\\ 
\> unsigned buffer\_offset)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

The function writes a partial line of pixel data to the registered image in SDRAM.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[line]The image line number to be written.
\item[image\_no]The image number whose line is to be written.
\item[buffer{[}{]}]The buffer which is to be written to the image.
\item[line\_offset]The offset in pixels to begin the write of the image line from.
\item[word\_count]The number of words to write to the image line.
\item[buffer\_offset]The offset from the begining of the buffer to write from in words.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_image\_read\_partial\_line\_p (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_image_read_partial_line_p}void display\_controller\_image\_read\_partial\_line\_p(\= chanend c\_server,\\ 
\> unsigned line,\\ 
\> unsigned image\_no,\\ 
\> intptr\_t buffer,\\ 
\> unsigned line\_offset,\\ 
\> unsigned word\_count,\\ 
\> unsigned buffer\_offset)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

The function writes a partial line of pixel data to the registered image in SDRAM.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[line]The image line number to be written.
\item[image\_no]The image number whose line is to be written.
\item[buffer]A pointer to the buffer which is to be written to the image.
\item[line\_offset]The offset in pixels to begin the write of the image line from.
\item[word\_count]The number of words to write to the image line.
\item[buffer\_offset]The offset from the begining of the buffer to write from in words.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_register\_image (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_register_image}unsigned display\_controller\_register\_image(\= chanend c\_server,\\ 
\> unsigned img\_width\_words,\\ 
\> unsigned img\_height\_lines)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Registers an image with the display controller.


Returns an image handle to refer to the image from then on.


This function has the following parameters:

\begin{option}

\item[server]The channel from the client application to the display\_controller.
\item[img\_width\_words]The width of the image in words.
\item[img\_height\_lines]The height of the image in lines(pixels).
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_wait\_until\_idle (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_wait_until_idle}void display\_controller\_wait\_until\_idle(\= chanend c\_server,\\ 
\> unsigned buffer{[}{]})
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Makes the display controller wait until the current SDRAM service has completed.


This function has the following parameters:

\begin{option}

\item[server]The channel from the client application to the display\_controller.
\item[buffer]The buffer which is to be written to the image.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_wait\_until\_idle\_p (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_wait_until_idle_p}void display\_controller\_wait\_until\_idle\_p(\= chanend c\_server,\\ 
\> intptr\_t buffer)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Makes the display controller wait until the current SDRAM service has completed.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[buffer]A pointer to the buffer which is to be written to the image.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_frame\_buffer\_commit (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_frame_buffer_commit}void display\_controller\_frame\_buffer\_commit(\= chanend c\_server,\\ 
\> unsigned image\_no)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Commits the image to the display controller to be displayed on the LCD screen when the current image is completly displayed.


The display controller contains a single next image number buffer meaning that if the buffer is empty (the previously commited image is already on the LCD screen) then the command will return immediatly. If the buffer is full then this function will block until the current image is on the LCD screen and the buffer is ready for a new entry. This behaviour ensures that frame commits will not overwrite.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[image\_no]The image handle of the image to be displayed as per the described behaviour.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy
\index{display\_controller\_frame\_buffer\_init (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:display_controller_frame_buffer_init}void display\_controller\_frame\_buffer\_init(\= chanend c\_server,\\ 
\> unsigned image\_no)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Commits the image to the display controller to be displayed on the LCD screen and initialises the display controller.


This must only be called once at the begining of the display controllers use.


This function has the following parameters:

\begin{option}

\item[server]The channel from the client application to the display\_controller.
\item[image\_no]The image handle of the image to be displayed as per the described behaviour.
\end{option}
\vspace{-3mm}


\end{indentation*}
\fussy


The transition API is as follows:
\index{transition\_wipe (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:transition_wipe}unsigned transition\_wipe(\= chanend c\_server,\\ 
\> unsigned frame\_buffer{[}2{]},\\ 
\> unsigned image\_from,\\ 
\> unsigned image\_to,\\ 
\> unsigned frames,\\ 
\> unsigned cur\_fb\_index)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Transition effect: A -\textgreater{} B as a wipe, i.e.


B wipes to A from the right.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[frame\_buffer]An array of the frame buffer image handles.
\item[image\_from]The image handle of the image to transition from.
\item[image\_to]The image handle of the image to transition to.
\item[frames]The number of frame to take over the course of the transisiton.
\item[cur\_fb\_index]The initial index of the current frame in the frame\_buffer .
\end{option}
\vspace{-3mm}



This function returns: 

The final index of the current frame in the frame\_buffer .

\end{indentation*}
\fussy
\index{transition\_slide (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:transition_slide}unsigned transition\_slide(\= chanend c\_server,\\ 
\> unsigned frame\_buffer{[}2{]},\\ 
\> unsigned image\_from,\\ 
\> unsigned image\_to,\\ 
\> unsigned frames,\\ 
\> unsigned cur\_fb\_index)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Transition effect: A -\textgreater{} B as a slide, i.e.


B slides over A from the right.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[frame\_buffer]An array of the frame buffer image handles.
\item[image\_from]The image handle of the image to transition from.
\item[image\_to]The image handle of the image to transition to.
\item[frames]The number of frame to take over the course of the transisiton.
\item[cur\_fb\_index]The initial index of the current frame in the frame\_buffer .
\end{option}
\vspace{-3mm}



This function returns: 

The final index of the current frame in the frame\_buffer .

\end{indentation*}
\fussy
\index{transition\_roll (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:transition_roll}unsigned transition\_roll(\= chanend c\_server,\\ 
\> unsigned frame\_buffer{[}2{]},\\ 
\> unsigned image\_from,\\ 
\> unsigned image\_to,\\ 
\> unsigned frames,\\ 
\> unsigned cur\_fb\_index)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Transition effect: A -\textgreater{} B as a roll, i.e.


B rolls on from the right and A rolls off to the right.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[frame\_buffer]An array of the frame buffer image handles.
\item[image\_from]The image handle of the image to transition from.
\item[image\_to]The image handle of the image to transition to.
\item[frames]The number of frame to take over the course of the transisiton.
\item[cur\_fb\_index]The initial index of the current frame in the frame\_buffer .
\end{option}
\vspace{-3mm}



This function returns: 

The final index of the current frame in the frame\_buffer .

\end{indentation*}
\fussy
\index{transition\_dither (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:transition_dither}unsigned transition\_dither(\= chanend c\_server,\\ 
\> unsigned frame\_buffer{[}2{]},\\ 
\> unsigned image\_from,\\ 
\> unsigned image\_to,\\ 
\> unsigned frames,\\ 
\> unsigned cur\_fb\_index)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Transition effect: A -\textgreater{} B as a dither, i.e.


B is revealed in 2 pixel chunks until A is gone.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[frame\_buffer]An array of the frame buffer image handles.
\item[image\_from]The image handle of the image to transition from.
\item[image\_to]The image handle of the image to transition to.
\item[frames]The number of frame to take over the course of the transisiton.
\item[cur\_fb\_index]The initial index of the current frame in the frame\_buffer .
\end{option}
\vspace{-3mm}



This function returns: 

The final index of the current frame in the frame\_buffer .

\end{indentation*}
\fussy
\index{transition\_alpha\_blend (C function)}
\vspace{-1.5\baselineskip}

\texttt{\begin{tabbing}\phantomsection\label{api:transition_alpha_blend}unsigned transition\_alpha\_blend(\= chanend c\_server,\\ 
\> unsigned frame\_buffer{[}2{]},\\ 
\> unsigned image\_from,\\ 
\> unsigned image\_to,\\ 
\> unsigned frames,\\ 
\> unsigned cur\_fb\_index)
\end{tabbing}}

\vspace{-2mm}
\sloppy
\begin{indentation*}{\blockindentlen}{0mm}

Transition effect: A -\textgreater{} B as a fade, i.e.


A fades away as B fades in.


This function has the following parameters:

\begin{option}

\item[c\_server]The channel from the client application to the display\_controller.
\item[frame\_buffer]An array of the frame buffer image handles.
\item[image\_from]The image handle of the image to transition from.
\item[image\_to]The image handle of the image to transition to.
\item[frames]The number of frame to take over the course of the transisiton.
\item[cur\_fb\_index]The initial index of the current frame in the frame\_buffer .
\end{option}
\vspace{-3mm}



This function returns: 

The final index of the current frame in the frame\_buffer .

\end{indentation*}
\fussy


The transitions use the display controller API.
\end{fullwidth}%


% NON-FULLWIDTH SECTION
\clearpage
\chapter{Programming guide}
\label{programming:}\label{programming:programming-guide}\label{programming::doc}%summary!
\begin{inthisdocument}
\item \nameref{programming:shared-memory-interface}
\item \nameref{programming:source-code-structure}
\item \nameref{programming:executing-the-project}
\item \nameref{programming:software-requirements}
\end{inthisdocument}




% NON-FULLWIDTH SECTION
\section{Shared memory interface}
\label{programming:shared-memory-interface}

The display controller uses a shared memory interface to move the large amount of data around from tile to tile efficiently. This means that the \verb`display_controller`, \verb`sdram_server` and \verb`lcd_server` must be one the same tile.



% NON-FULLWIDTH SECTION
\section{Source code structure}
\label{programming:source-code-structure}
\begin{figure}[h]\begin{sidecaption}{Project structure}
\small
\begin{tabularx}{\linewidth}{llY}
\Toprule
\textbf{Project} & \textbf{File} & \textbf{Description}\\
\midrule
module\_display\_controller & \verb`display_controller.h` & Header file containing the APIs for the display controller component.\\
 & \verb`display_controller.xc` & File containing the implementation of the display controller component.\\
 & \verb`display_controller_client.xc` & File containing the implementation of the display controller client functions.\\
 & \verb`display_controller_internal.h` & Header file containing the user configurable defines for the display controller component.\\
 & \verb`transitions.h` & Header file containing the APIs for the display controller transitions.\\
 & \verb`transitions.xc` & File containing the implementation of the display controller transitions.\\
\bottomrule
\end{tabularx}

\end{sidecaption}
\end{figure} \DocumentFooterFix



% NON-FULLWIDTH SECTION
\section{Executing the project}
\label{programming:executing-the-project}

The module by itself cannot be built or executed separately - it must be linked in to an application. Once the module is linked to the application, the application can be built and tested for driving a LCD screen.
\begin{description}
\item[The following modules should be added to the list of MODULES in order to link the component to the application project]\begin{enumerate}
\item   \verb`module_display_controller`

\item   \verb`module_lcd`

\item   \verb`module_sdram`

\end{enumerate}


\item[Now the module is linked to the application and can be used directly. Additionally, if the use of the touch controller is nessessary then]\begin{enumerate}
\item   \verb`module_touch_controller_lib` or \verb`module_touch_controller_server`

\item   \verb`module_i2c_master`

\end{enumerate}


\end{description}



should be added to the list of MODULES.



% NON-FULLWIDTH SECTION
\section{Software requirements}
\label{programming:software-requirements}

The module is built on xTIMEcomposer version 12.0
The module can be used in version 12.0 or any higher version of xTIMEcomposer.



% NON-FULLWIDTH SECTION
\clearpage
\chapter{Example applications}
\label{examples:example-application}\label{examples::doc}%last summary
\begin{inthisdocument}
\item \nameref{examples:app-display-controller-demo}
\item \nameref{examples:application-notes}
\end{inthisdocument}



This tutorial describes a demo application that uses the display controller module. \Sec~\ref{hw:sec-hardware-platforms} describes the required hardware setup to run the demos.



% NON-FULLWIDTH SECTION
\section{app\_display\_controller\_demo}
\label{examples:app-display-controller-demo}

This application demonstrates how the \verb`lcd_module` is used to write image data to the LCD screen whilst imposing no real time constraints on the application. The purpose of this demonstration is to show how data is passed to the \verb`display_controller`. This application also demonstrates an interactive display using \verb`touch_controller_lib` module.



% NON-FULLWIDTH SECTION
\section{Application notes}
\label{examples:application-notes}


% NON-FULLWIDTH SECTION
\subsection{Getting started}
\label{examples:getting-started}\begin{enumerate}
\item   Plug the XA-SK-LCD Slice Card into the `TRIANGLE' slot of the sliceKIT Core Board

\item   Plug the XA-SK-SDRAM Slice Card into the `STAR' slot of the sliceKIT Core Board

\item   Open \verb`app_display_controller_demo.xc` and build the project.

\item   Run the program ensuring that it is run from the project directory where the TGA images are.

\end{enumerate}



The output produced should look like a series of images transitioning on the LCD when the screen is touched.



\posttoc

\finish
